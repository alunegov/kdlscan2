package lng

import (
	"bufio"
	"errors"
	"os"
	"regexp"
	"strconv"
	"strings"
	"time"
)

const (
	parseComment  = iota // обработка примечания
	parseHumanize        // обработка настроек Humanize
	parseSections        // обработка секций
	parseKeys            // обработка ключей секции
)

// Load загружает (и разбирает) lng-файл с диска
func Load(fileName string) (*File, error) {
	res := NewFile()

	f, err := os.Open(fileName)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	var section *Section
	state := parseComment
	genByRE := regexp.MustCompile("; Generated by .+, (.+)")

	s := bufio.NewScanner(f)
	for s.Scan() {
		baseLine := s.Text()

		switch state {
		case parseComment:
			if !strings.HasPrefix(baseLine, "; ") {
				state = parseHumanize
				continue
			}

			// "; Generated by K.D.L. Scanner, 26.07.2018 14:40:59"
			// "; Generated by kdlscan2, 2018-08-07T15:14:49+05:00"
			s := genByRE.FindStringSubmatch(baseLine)
			if s == nil {
				continue
			}

			if t, err := parseUpdateTime(s[1]); err == nil {
				res.UpdateTime = t
			}
			// else оставляем time.Now()
		case parseHumanize:
			// TODO: обработка Humanize, чтобы использовать их при записи файла
			state = parseSections
		case parseSections:
			if !strings.HasPrefix(baseLine, "[") {
				continue
			}

			section, _ = res.NewSection(baseLine)
			state = parseKeys
		case parseKeys:
			if baseLine == "" {
				state = parseSections
				continue
			}

			flag, name, version, value := parseKey(baseLine)
			_, _ = section.NewKey(flag, name, version, value)
		}
	}
	if err := s.Err(); err != nil {
		return nil, err
	}

	res.Changed = false

	return res, nil
}

func parseKey(s string) (KeyFlag, string, KeyVersion, string) {
	delim := strings.Index(s, "=")

	k := s[:delim]

	kf := Std
	if strings.HasPrefix(k, "(") {
		if k[1] == '!' {
			kf = Modified
		} else {
			kf = Deleted
		}
		k = k[3:]
	}

	kv := 0
	if i := strings.Index(k, "{"); i != -1 {
		kv, _ = strconv.Atoi(k[i+1 : len(k)-1])
		k = k[:len(k)-3]
	}

	v := s[delim+1:]

	return kf, k, KeyVersion(kv), v
}

// parseUpdateTime время из строки. Строка может быть в двух форматах - генерируемый нами (kdlscan2) или оригинальным
// kdlscan.
func parseUpdateTime(s string) (time.Time, error) {
	layouts := []string{time.RFC3339, "02.01.2006 15:04:05"}

	for _, l := range layouts {
		if t, err := time.ParseInLocation(l, s, time.Local); err == nil {
			return t, nil
		}
	}

	return time.Time{}, errors.New("unsupported time layout")
}

// Save сохраняет lng-файл на диск
func Save(file *File, fileName string) error {
	f, err := os.Create(fileName)
	if err != nil {
		return err
	}
	defer f.Close()

	w := bufio.NewWriter(f)
	if _, err = w.WriteString("; Kryvich's Delphi Localizer Language File." + "\r\n" +
		"; Generated by kdlscan2, " + file.UpdateTime.Format(time.RFC3339) + "\r\n" +
		"\r\n"); err != nil {
		return err
	}
	// TODO: определять настройки Humanize при загрузке файла
	if _, err = w.WriteString("Humanize=1" + "\r\n" +
		"HumanizedCR=\\^" + "\r\n" +
		"HumanizedCRLF=\\+" + "\r\n" +
		"\r\n"); err != nil {
		return err
	}
	for _, s := range file.Sections() {
		if _, err = w.WriteString(s.Name() + "\r\n"); err != nil {
			return err
		}
		for _, k := range s.Keys() {
			if _, err = w.WriteString(k.String() + "\r\n"); err != nil {
				return err
			}
		}
		if _, err = w.WriteString("\r\n"); err != nil {
			return err
		}
	}
	if err = w.Flush(); err != nil {
		return err
	}

	return nil
}
